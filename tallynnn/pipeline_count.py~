"""===========================
Pipeline count
===========================

Overview
========

The aim of this pipeline is to take a nanopore input fastq and then process
the file so a counts matrix is generated for downstream differential expression.

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.yml` file.
CGATReport report requires a :file:`conf.py` and optionally a
:file:`cgatreport.ini` file (see :ref:`PipelineReporting`).

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_cat_fastq.py config

Input files
-----------

fastq.gz file of nanopore reads that have been sequenced with trimers at
the 5' and 3' end. Data should be added to the data.dir folder.

Pipeline output
===============

A counts matrix with sample as columns and rows as either transcripts or genes. 


Code
====

"""
import sys
import os
import pysam
from ruffus import *
import cgatcore.iotools as iotools
import cgatcore.pipeline as P
import cgatcore.experiment as E
from cgatcore.pipeline import cluster_runnable

# load options from the config file
PARAMS = P.get_parameters(
    ["%s/pipeline.yml" % os.path.splitext(__file__)[0],
     "../pipeline.yml",
     "pipeline.yml"])


SEQUENCESUFFIXES = ("*.fastq.gz")

FASTQTARGET = tuple([os.path.join("data.dir/", suffix_name)
                       for suffix_name in SEQUENCESUFFIXES])

@collate(FASTQTARGET,
         regex("data.dir/(\S+).fastq.gz"),
         r"\1_filtered.fastq.gz")
def filter_fastq(infile, outfile):
    '''filter each fastq so that the length of each read is less than 300 bp'''

    with pysam.FastxFile(str(infile[0])) as fh:
        outfile = iotools.open_file(outfile, "w")

        for record in fh:
            if len(record.sequence) < 300:
                pass
            else:
                outfile.write("@%s\n%s\n+\n%s\n" % (record.name, record.sequence, record.quality))


@transform(filter_fastq,
         regex("(\S+)_filtered.fastq.gz"),
         r"\1_polyA.fastq.gz")
def polya_correct(infile, outfile):

    tab = str.maketrans("ACTG", "TGAC")

    def reverse_complement_table(seq):
        return seq.translate(tab)[::-1]

    E.warn(outfile)
    outfile = iotools.open_file(str(outfile), "w")
    log =  iotools.open_file(str(outfile) + ".log","w")
    n = 0
    y = 0
    with pysam.FastxFile(infile[0]) as fh:

        for record in fh:
            y +=1
            if len(record.sequence) < 300:
                pass
            else:
                seq = record.sequence[50:300]
                m=regex.findall("(TTTTTTTTTTTTTTTTTTTT){e<=3}", str(seq))
                if m:
                    n +=1
                    sequence = reverse_complement_table(str(record.sequence))
                    outfile.write("@%s\n%s\n+\n%s\n" % (record.name, sequence, record.quality))
                else:
                    seq = record.sequence[-30:-200:]
                    m=regex.findall("(AAAAAAAAAAAAAAAAAAAA){e<=3}", str(seq))
                    if m:
                        n +=1
                        outfile.write("@%s\n%s\n+\n%s\n" % (record.name, record.sequence, record.quality))
                        outfile.close()
                        log.close()

@follows(filter_fastq)
def full():
    pass

def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))    
