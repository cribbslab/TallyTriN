##############################################################################
#
#   Botnar Resaerch Centre
#
#   $Id$
#
#   Copyright (C) 2022 Adam Cribbs
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
###############################################################################

"""
=================
Pipeline nanopore
=================


Overview
==================

This workflow processes bulk Nanopore libraries that contain two homotrimeric UMI sequences. The aim of this pipeline is to generate mapping for both a gene level and transcript level counts matrix for downstream RNA-seq processing.

Usage
=====

To generate the config file to change the running of the pipeline you need to
run:

tallynnn nanopore config

This will generate a pipeline.yml file that the user can modify to change the
output of the pipeline. Once the user has modified the pipeline.yml file the
pipeline can then be ran using the following commandline command:

tallynnn nanopore make full -v5

You can run the pipeline locally (without a cluster) using --local

tallynn nanopore make full -v5 --local

Configuration
-------------

The pipeline uses CGAT-core as the pipeline language. Please see the
docuemntation for how to install tallynnn.


Input files
-----------

The workflow requires the following inputs:
* a single fastq file generated by guppy basecalling
* a transcriptome genome of your choice
* a genome fasta file
* a minimap2 junction bed generated following minimap2 instructions: https://github.com/lh3/minimap2/blob/master/README.md
* a gtf file

Pipeline output
==================

There are main output of this pipeline is the generation of a counts matrix for
bulk RNA-seq analyses. 

Code
==================

"""
from ruffus import *

import sys
import os
import re
import sqlite3
import glob

import cgatcore.pipeline as P
import cgatcore.experiment as E
import cgatcore.database as database

# Load options from the config file

PARAMS = P.get_parameters(
    ["%s/pipeline.yml" % os.path.splitext(__file__)[0],
     "../pipeline.yml",
     "pipeline.yml"])


# Determine the location of the input fastq files

try:
    PARAMS['data']
except NameError:
    DATADIR = "."
else:
    if PARAMS['data'] == 0:
        DATADIR = "."
    elif PARAMS['data'] == 1:
        DATADIR = "data"
    else:
        DATADIR = PARAMS['data']


SEQUENCESUFFIXES = ("*.fastq")
SEQUENCEFILES = tuple([os.path.join(DATADIR, suffix_name)
                       for suffix_name in SEQUENCESUFFIXES])


@follows(mkdir("processed_fastq.dir"))
@transform('data.dir/*.fastq.gz', "split_tmp.dir/out*")
def reversecomp_fastq(infile, outfiles):
    '''
    Check for the orientation of the fastq file based on the polyA tail and
    reverse complement to maintain appropriate orientation.
    '''

    PYTHON_ROOT = os.path.join(os.path.dirname(__file__), "python/")

    statement = ''''''

    P.run(statement)


@follows(reversecomp_fastq)
def full():
    pass


def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)

if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
